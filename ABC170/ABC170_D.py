'''
方針
    1 ～ 10^6(Aの最大値) までの全ての数について、割り切れる数をカウント
    カウント == 1 ならば、他の数では割り切れないので、そのような数の個数が答え

工夫
    そのままの実装では、最悪ケース : 1 1 1 1 ... で、TLEする
    対策として、
        1. Aを昇順ソートする
        2. A[i]がA[i-1]と同じならば、2倍以上の倍数についてはスキップ
    とする
'''

import numpy as np

def main():
    N = int(input())
    A = list(map(int, input().split()))
    A.sort()
    d = np.zeros(A[-1]+1, dtype=np.uint64)  # 約数カウント。配列長さは、Aの最大値+1 で十分
    for i in range(N):
        a = A[i]
        a1 = A[i-1]
        if a != a1:     # 初出の数なら
            d[a::a] += 1    # aからaごとに+1する (範囲内の全ての倍数に、約数カウント+1)
        else:           # 重複なら
            d[a] += 1       # 自身のカウントを上げるだけで十分 (2倍以上はスキップ)
    print(np.count_nonzero(d[A] == 1))  # Aのうち、約数カウントが1となったものの個数が答え

main()

