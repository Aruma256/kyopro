'''
・基本的には素直なシミュレーションを行う
・ループ分のシミュレーションを省略することでTLEを回避
・Kは「残りのワープ数」と考える

K回のワープ中にループが含まれる場合、
1. 素直なシミュレーションを行う。このとき、Kを減算していく。
2. ループを検出したら、Kからループ長をできるだけ多く引くことで、計算を省略する。
3. 残りのステップ数、再度シミュレーションを行う
という手順で答えを求められる。
なお、ループが含まれない場合も1のみで答えを求められる。
'''

def main():
    N, K = map(int, input().split())
    A = [a-1 for a in map(int, input().split())]    # 0-indexed に変換
    B = [None]*N    # 何ステップ目に到達したかを記録。Noneなら未到達を表す
    now = 0         # 現在地
    step = 0        # ステップ数
    B[now] = 0      # 開始地点は、0ステップ目に到達済みとする
    while K:
        now = A[now]    # 現在地を更新 
        step += 1
        K -= 1
        if B[now] is not None:  # ループを検出したら...
            K %= (step - B[now])      # Kからループ長さを引けるだけ引く
        else:
            B[now] = step  # 到達したステップ数を記録
    print(now+1)    # 1-indexed に再変換

main()

# step変数を使わずにKだけでも実装できるけど気にしない
# ループ長を引く操作は1回だけで十分だけど、気にしない
